# ğŸ”¹ PART 1 â€” 30-DAY DAILY PROMPTS (15 MIN / DAY)

### â± Daily Structure (always the same)

- **5 min** â†’ Java / Spring Boot
    
- **5 min** â†’ JavaScript / React
    
- **5 min** â†’ Python / AI Math
    

Use **Recall / Apply / Explain** only.

---

## ğŸ“… DAYS 1â€“10 (CORE RECALL)

### Day 1

- Java: Explain how `HashMap` works internally
    
- JS: Explain closure in your own words
    
- AI Math: Compute dot product of two vectors
    

### Day 2

- Java: Difference between interface & abstract class
    
- JS: Predict output (hoisting example)
    
- AI Math: Mean & variance of a small dataset
    

### Day 3

- Java: Explain JVM memory areas
    
- JS: Explain `this` in arrow vs normal function
    
- AI Math: Why normalization matters (numeric example)
    

### Day 4

- Java: Exception vs RuntimeException
    
- JS: Explain event loop (no code)
    
- AI Math: Vector magnitude & intuition
    

### Day 5

- Java: Explain immutability
    
- JS: Difference between `map`, `forEach`, `reduce`
    
- AI Math: Compute cosine similarity
    

### Day 6

- Java: Predict output (inheritance example)
    
- JS: Explain scope chain
    
- AI Math: Simple linear function evaluation
    

### Day 7

- Java: Explain equals vs hashCode
    
- JS: Explain truthy/falsy
    
- AI Math: Matrix shape reasoning
    

### Day 8

- Java: Explain dependency injection
    
- JS: Explain props vs state
    
- AI Math: Loss function intuition
    

### Day 9

- Java: Explain `final` keyword uses
    
- JS: Explain controlled components
    
- AI Math: Compute one MSE example
    

### Day 10

- Java: Explain garbage collection basics
    
- JS: Explain render cycle in React
    
- AI Math: Explain gradient intuition (no calculus)
    

---

## ğŸ“… DAYS 11â€“20 (APPLICATION)

### Day 11

- Java: Convert loop â†’ stream
    
- JS: Recreate `map`
    
- AI Math: One gradient descent step (numbers)
    

### Day 12

- Java: DTO vs Entity use case
    
- JS: Lift state example
    
- AI Math: Learning rate effect
    

### Day 13

- Java: REST request lifecycle
    
- JS: Conditional rendering logic
    
- AI Math: Feature scaling example
    

### Day 14

- Java: Thread safety explanation
    
- JS: Predict async output
    
- AI Math: MAE vs MSE comparison
    

### Day 15

- Java: Custom exception design
    
- JS: useEffect dependency reasoning
    
- AI Math: Overfitting intuition
    

### Day 16

- Java: Stream `map` vs `flatMap`
    
- JS: Explain memoization
    
- AI Math: Bias vs variance tradeoff
    

### Day 17

- Java: Transaction boundaries
    
- JS: Explain refs vs state
    
- AI Math: Linear regression logic
    

### Day 18

- Java: Explain lazy loading
    
- JS: Re-render triggers
    
- AI Math: Gradient sign meaning
    

### Day 19

- Java: Predict stream output
    
- JS: Explain pure function
    
- AI Math: Simple prediction error
    

### Day 20

- Java: Explain singleton pros/cons
    
- JS: Explain key prop
    
- AI Math: Loss surface intuition
    

---

## ğŸ“… DAYS 21â€“30 (CONNECTION & DEPTH)

### Day 21

- Java: Explain immutability & threads
    
- JS: Closure vs class fields
    
- AI Math: Math â†’ Python translation
    

### Day 22

- Java: Compare List vs Set
    
- JS: Compare map vs reduce
    
- AI Math: Vectorized thinking
    

### Day 23

- Java: Explain API error handling
    
- JS: Error boundaries
    
- AI Math: Numerical stability
    

### Day 24

- Java: Explain Spring bean scopes
    
- JS: Explain custom hooks
    
- AI Math: Regularization intuition
    

### Day 25

- Java: Predict multithread output
    
- JS: Async/await flow
    
- AI Math: Optimization intuition
    

### Day 26

- Java: Explain design tradeoff
    
- JS: Performance bottleneck causes
    
- AI Math: Feature importance idea
    

### Day 27

- Java: Explain caching
    
- JS: Explain debouncing
    
- AI Math: Batch vs stochastic GD
    

### Day 28

- Java: Explain clean architecture
    
- JS: Explain separation of concerns
    
- AI Math: Pipeline thinking
    

### Day 29

- Java: Teach one concept aloud
    
- JS: Teach one concept aloud
    
- AI Math: Teach one concept aloud
    

### Day 30

- Java: Weakest topic recall
    
- JS: Weakest topic recall
    
- AI Math: Weakest topic recall
    

---

# ğŸ”¹ PART 2 â€” PRINTABLE ONE-PAGE ROADMAP

`DAILY (15 MIN) ------------------------- 5 min  â†’ Java / Spring 5 min  â†’ JS / React 5 min  â†’ Python / AI Math  RULES ------------------------- â€¢ Recall > Read â€¢ No docs for first 4 min â€¢ Stop at 15 min â€¢ 1-sentence reflection  WEEKLY FLOW ------------------------- Monâ€“Fri â†’ New prompts Sat     â†’ Weakest topic Sun     â†’ Off  FOCUS ------------------------- â€¢ Explain from memory â€¢ Apply with tiny examples â€¢ Connect math â†’ code  REFLECTION ------------------------- "Today I almost forgot ___"`

(Print this. Stick it near your desk.)

---

# ğŸ”¹ PART 3 â€” AI MATH â†’ CODE DRILLS

Use **Python**, no libraries first.

---

### ğŸ”¢ Drill 1: Dot Product

**Math:**

xâ‹…y=âˆ‘xiyix Â· y = \sum x_i y_ixâ‹…y=âˆ‘xiâ€‹yiâ€‹

**Code Task:**  
Implement dot product manually.

---

### ğŸ”¢ Drill 2: Mean Squared Error

**Math:**

MSE=1nâˆ‘(yâˆ’y^)2MSE = \frac{1}{n} \sum (y - \hat{y})^2MSE=n1â€‹âˆ‘(yâˆ’y^â€‹)2

**Code Task:**  
Write function computing MSE.

---

### ğŸ”¢ Drill 3: Gradient Step

**Math:**

w=wâˆ’Î±â‹…gradientw = w - \alpha \cdot gradientw=wâˆ’Î±â‹…gradient

**Code Task:**  
Update one weight using numbers.

---

### ğŸ”¢ Drill 4: Normalization

**Math:**

xâ€²=xâˆ’Î¼Ïƒx' = \frac{x - \mu}{\sigma}xâ€²=Ïƒxâˆ’Î¼â€‹

**Code Task:**  
Normalize a small list.

---

### ğŸ”¢ Drill 5: Linear Prediction

**Math:**

y=wx+by = wx + by=wx+b

**Code Task:**  
Predict output for multiple inputs.

---

### ğŸ”¢ Drill 6: Loss Comparison

**Math:** MAE vs MSE

**Code Task:**  
Compute both for same data, compare.

---

## ğŸ§  FINAL NOTE (IMPORTANT)

This system:

- Prevents forgetting
    
- Builds confidence
    
- Fits real life
    
- Scales forever
    

You are no longer â€œpracticing randomlyâ€.